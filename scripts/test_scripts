        path_list <- list.files(path = here(), pattern = ".xlsx")
        tbl_list <- lapply(path_list, read_xlsx)
        aneuDat <- map2(.x = path_list, .y= tbl_list, .f = ~data.frame(class=.x, .y)) %>% 
          do.call(rbind, .) %>% 
          as_tibble() %>% 
          clean_names() %>%
          mutate(ploidy =  apply(.[,2:ncol(.)], 1, classifPloidy)) %>% 
          mutate_at(.vars = vars(starts_with("Chr")), 
                    .funs = ~ifelse(. == 0, 1, 
                                    ifelse(. <= maxChr, ., maxChrPlus1)))
        letter_ids <- names(table(aneuDat$class))
        matr_list_all <- lapply(letter_ids, function(x)
          return_chr_prop_matr(aneuDat,x, maxPair = maxChrPlus1)
        )
        names(matr_list_all) = letter_ids
        matr_list_all %>% map2(.y=names(.),
                                    .f=~create_perc_matr2(matr = .x, 
                                        title = .y, minChr = 1, 
                                        maxChr = maxChrPlus1, xlab = "", ylab=""))
      }





     letter_ids <- names(table(aneuDat$class))      
      
      matr_list_all <- lapply(letter_ids, function(x)
        return_chr_prop_matr(aneuDat,x, maxPair = maxChrPlus1)
      )
      names(matr_list_all) = letter_ids
      gridPlots <- matr_list_all %>% map2(.y=names(.),
                             .f=~create_perc_matr2(matr = .x, 
                                 title = .y, minChr = 1, 
                                 maxChr = maxChrPlus1, xlab = "", ylab=""))


     if(interactive()){
        path_list_test <- list.files(path = here(), pattern = ".xlsx")
        tbl_list_test <- lapply(path_list_test, read_xlsx)
        aneuDat_test <- map2(.x = path_list_test, .y= tbl_list_test, .f = ~data.frame(clss=.x, .y)) %>% 
          do.call(rbind, .) %>% 
          as_tibble() %>% 
          clean_names() %>%
          mutate(ploidy =  apply(.[,2:ncol(.)], 1, classifPloidy)) %>% 
          mutate_at(.vars = vars(starts_with("Chr")), 
                    .funs = ~ifelse(. == 0, 1, 
                                    ifelse(. <= maxChr, ., maxChrPlus1)))
        letter_ids_test <- names(table(aneuDat_test$clss))
        matr_list_all_test <- lapply(letter_ids_test, function(x)
          return_chr_prop_matr(aneuDat_test,x, maxPair = maxChrPlus1)
        )
        names(matr_list_all_test) = letter_ids_test
        gridPlots <- matr_list_all_test %>% map2(.y=names(.),
                                    .f=~create_perc_matr2(matr = .x, 
                                        title = .y, minChr = 1, 
                                        maxChr = maxChrPlus1, xlab = "", ylab=""))
      }
      return(gridPlots)    
    }
  })






    output$plots <- renderUI({
    letter_ids <- names(table(aneuDat_r()$class))      
    
    matr_list_all <- lapply(letter_ids, function(x)
      return_chr_prop_matr(aneuDat_r(),x, maxPair = maxChrPlus1)
    )
    names(matr_list_all) = letter_ids
    gridPlots <- matr_list_all %>% 
      map2(.y=names(.),.f=~create_perc_matr2(matr = .x, 
          title = .y, minChr = 1, maxChr = maxChrPlus1, 
          xlab = "", ylab=""))
    return(gridPlots)
  })






https://www.ncbi.nlm.nih.gov/pmc/articles/PMC1224735/
ftp://ftp.ncbi.nlm.nih.gov/sky-cgh/DATA/

  max_plots <- isolate(length(unique(aneuDat_r()$class)))
  for (i in 1:max_plots) {
    # Need local so that each item gets its own number. Without it, the value
    # of i in the renderPlot() will be the same across all instances, because
    # of when the expression is evaluated.
    local({
      my_i <- i
      plotname <- paste("plot", my_i, sep="")
      
      output[[plotname]] <- renderPlot({
        letter_ids <- names(table(aneuDat_r()$class))      
        
        matr_list_all <- lapply(letter_ids, function(x)
          return_chr_prop_matr(aneuDat_r(),x, maxPair = maxChrPlus1)
        )
        names(matr_list_all) = letter_ids
        gridPlots <- matr_list_all[my_i] %>% 
          map2(.y=names(.),.f=~create_perc_matr2(matr = .x, 
                                                 title = .y, minChr = 1, maxChr = maxChrPlus1, 
                                                 xlab = "", ylab=""))
        return(gridPlots)
      })
    })
  }
  


  tags$li(
                "The 6th row (norm_sum_ideal_obs_diff) represents the chromosomal instability index.
                This was calculated as the Euclidean distance from the 'ideal' diploid state and was calculated as follows:",
                tags$ul(
                  tags$li(
                    "Take the difference between all chromosomes and the diploid (2n) state"
                  ),
                  tags$li("Sum the absolute value of this difference")
                )
              ),